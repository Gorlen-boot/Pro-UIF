// Generated by gencpp from file my_project_test/can_out_MT4000.msg
// DO NOT EDIT!


#ifndef MY_PROJECT_TEST_MESSAGE_CAN_OUT_MT4000_H
#define MY_PROJECT_TEST_MESSAGE_CAN_OUT_MT4000_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace my_project_test
{
template <class ContainerAllocator>
struct can_out_MT4000_
{
  typedef can_out_MT4000_<ContainerAllocator> Type;

  can_out_MT4000_()
    : driverMode_b(false)
    , gearP_b(false)
    , loadBrake_b(false)
    , turtle_b(false)
    , takeOver_b(false)
    , gear(0)
    , wheelAngle(0)
    , velocity(0)
    , rpm(0)
    , throttle(0)
    , electronic_break(0)
    , vechleId(0)
    , engineSpeed(0)
    , batteryVoltage(0)
    , faultTotal(0)
    , dump_bed(0)
    , loading(0)
    , faultCode(0)
    , elecControlTemp(0)
    , oil(0)
    , mileage(0)
    , lighting_b(false)
    , horn_b(false)
    , leftLamp_b(false)
    , rightLamp_b(false)
    , bothLamp_b(false)  {
    }
  can_out_MT4000_(const ContainerAllocator& _alloc)
    : driverMode_b(false)
    , gearP_b(false)
    , loadBrake_b(false)
    , turtle_b(false)
    , takeOver_b(false)
    , gear(0)
    , wheelAngle(0)
    , velocity(0)
    , rpm(0)
    , throttle(0)
    , electronic_break(0)
    , vechleId(0)
    , engineSpeed(0)
    , batteryVoltage(0)
    , faultTotal(0)
    , dump_bed(0)
    , loading(0)
    , faultCode(0)
    , elecControlTemp(0)
    , oil(0)
    , mileage(0)
    , lighting_b(false)
    , horn_b(false)
    , leftLamp_b(false)
    , rightLamp_b(false)
    , bothLamp_b(false)  {
  (void)_alloc;
    }



   typedef uint8_t _driverMode_b_type;
  _driverMode_b_type driverMode_b;

   typedef uint8_t _gearP_b_type;
  _gearP_b_type gearP_b;

   typedef uint8_t _loadBrake_b_type;
  _loadBrake_b_type loadBrake_b;

   typedef uint8_t _turtle_b_type;
  _turtle_b_type turtle_b;

   typedef uint8_t _takeOver_b_type;
  _takeOver_b_type takeOver_b;

   typedef int8_t _gear_type;
  _gear_type gear;

   typedef int16_t _wheelAngle_type;
  _wheelAngle_type wheelAngle;

   typedef uint16_t _velocity_type;
  _velocity_type velocity;

   typedef uint16_t _rpm_type;
  _rpm_type rpm;

   typedef uint8_t _throttle_type;
  _throttle_type throttle;

   typedef uint8_t _electronic_break_type;
  _electronic_break_type electronic_break;

   typedef uint8_t _vechleId_type;
  _vechleId_type vechleId;

   typedef uint16_t _engineSpeed_type;
  _engineSpeed_type engineSpeed;

   typedef uint16_t _batteryVoltage_type;
  _batteryVoltage_type batteryVoltage;

   typedef uint8_t _faultTotal_type;
  _faultTotal_type faultTotal;

   typedef uint8_t _dump_bed_type;
  _dump_bed_type dump_bed;

   typedef uint8_t _loading_type;
  _loading_type loading;

   typedef uint8_t _faultCode_type;
  _faultCode_type faultCode;

   typedef int8_t _elecControlTemp_type;
  _elecControlTemp_type elecControlTemp;

   typedef uint8_t _oil_type;
  _oil_type oil;

   typedef uint32_t _mileage_type;
  _mileage_type mileage;

   typedef uint8_t _lighting_b_type;
  _lighting_b_type lighting_b;

   typedef uint8_t _horn_b_type;
  _horn_b_type horn_b;

   typedef uint8_t _leftLamp_b_type;
  _leftLamp_b_type leftLamp_b;

   typedef uint8_t _rightLamp_b_type;
  _rightLamp_b_type rightLamp_b;

   typedef uint8_t _bothLamp_b_type;
  _bothLamp_b_type bothLamp_b;





  typedef boost::shared_ptr< ::my_project_test::can_out_MT4000_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::my_project_test::can_out_MT4000_<ContainerAllocator> const> ConstPtr;

}; // struct can_out_MT4000_

typedef ::my_project_test::can_out_MT4000_<std::allocator<void> > can_out_MT4000;

typedef boost::shared_ptr< ::my_project_test::can_out_MT4000 > can_out_MT4000Ptr;
typedef boost::shared_ptr< ::my_project_test::can_out_MT4000 const> can_out_MT4000ConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::my_project_test::can_out_MT4000_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::my_project_test::can_out_MT4000_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace my_project_test

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg'], 'my_project_test': ['/home/workSpace/Pro-UIF-master/src/my_project_test/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::my_project_test::can_out_MT4000_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::my_project_test::can_out_MT4000_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::my_project_test::can_out_MT4000_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
{
  static const char* value()
  {
    return "f717144ce310d9e9e5733e6820d8c923";
  }

  static const char* value(const ::my_project_test::can_out_MT4000_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xf717144ce310d9e9ULL;
  static const uint64_t static_value2 = 0xe5733e6820d8c923ULL;
};

template<class ContainerAllocator>
struct DataType< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
{
  static const char* value()
  {
    return "my_project_test/can_out_MT4000";
  }

  static const char* value(const ::my_project_test::can_out_MT4000_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# ros topic name : can_to_ros_MT4000\n\
# dada from MT4000 CAN\n\
\n\
## can id 0X20B\n\
bool driverMode_b           # 0: 有人驾驶，1： 无人驾驶\n\
bool gearP_b                # 驻车制动挡反馈， 1=开关动作，0=开关无动作\n\
bool loadBrake_b            # 装载制动挡反馈， 1=开关动作，0=开关无动作\n\
bool turtle_b               # 龟速模式反馈， 1=开关动作，0=开关无动作\n\
bool takeOver_b             # 0: 未接管，1：人工接管\n\
int8 gear                   # 档位反馈 0：空挡 1：前进档 2：倒车档\n\
int16 wheelAngle            # 前轮转向角度[-350,250]，1=0.1度，左转为正数最大25度，右转为负数最值为-35度\n\
uint16 velocity             # 实时速度，1=0.1km/h\n\
uint16 rpm                  # 驱动轮轮速, [0,3000]\n\
\n\
## can id 0x21B\n\
uint8 throttle              #油门踏板指令 1=1%, 0-100%\n\
uint8 electronic_break      #电制动踏板指令 1=1%, 0-100%\n\
\n\
## can id 0X22B\n\
uint8 vechleId              # 车辆识别码，[0,255]\n\
uint16 engineSpeed          # 发动机转速，[0,65535]\n\
uint16 batteryVoltage       # 电池电压，0-300   系统供电电压  1=0.1V\n\
uint8 faultTotal            # 整车故障, 0：无故障, 1：一般故障,2：严重故障,3：致命故障\n\
uint8 dump_bed              # 货箱举升实时角度反馈    0-100   货箱举升实时角度反馈  1=1%\n\
uint8 loading               # 载重量   0-255   载重量 1=1T\n\
\n\
## can id 0X28B\n\
uint8 faultCode             #故障代码   0-255     \n\
                                    # 0x00：无\n\
                                    # 0x01：系统故障（红）\n\
                                    # 0x02：系统故障（黄）\n\
                                    # 0x03：车辆低温故障\n\
                                    # 0x04：电控箱低温报警\n\
                                    # 0x05：电控箱高温报警\n\
                                    # 0x06：前制动压力故障\n\
                                    # 0x07：后制动压力故障\n\
                                    # 0x08：自动润滑故障\n\
                                    # 0x09：电制动高温故障\n\
                                    # 0x0A：制动压力低故障\n\
                                    # 0x0B：转向压力低故障\n\
                                    # 0x0C：燃油量低故障\n\
                                    # 0x0D：液压油温高故障\n\
                                    # 0x0E：液压油位低故\n\
                                    # 0x0F：预留\n\
int8 elecControlTemp        # 电控箱温度信息反馈 0-125 电控箱温度信息反馈 -40 offset\n\
uint8 oil                   # 燃油油位  0-100   燃油量 1=1%\n\
uint32 mileage              # 车辆总里程数    0-2^32  车辆总里程数  1=1m/Bit\n\
bool lighting_b             # 照明反馈, 0 无动作， 1 动作\n\
bool horn_b                 # 喇叭反馈, 0 无动作， 1 动作\n\
bool leftLamp_b\n\
bool rightLamp_b            # 转向灯反馈, 0 无动作， 1 动作\n\
bool bothLamp_b             # 双闪反馈, 0 无动作， 1 动作\n\
";
  }

  static const char* value(const ::my_project_test::can_out_MT4000_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.driverMode_b);
      stream.next(m.gearP_b);
      stream.next(m.loadBrake_b);
      stream.next(m.turtle_b);
      stream.next(m.takeOver_b);
      stream.next(m.gear);
      stream.next(m.wheelAngle);
      stream.next(m.velocity);
      stream.next(m.rpm);
      stream.next(m.throttle);
      stream.next(m.electronic_break);
      stream.next(m.vechleId);
      stream.next(m.engineSpeed);
      stream.next(m.batteryVoltage);
      stream.next(m.faultTotal);
      stream.next(m.dump_bed);
      stream.next(m.loading);
      stream.next(m.faultCode);
      stream.next(m.elecControlTemp);
      stream.next(m.oil);
      stream.next(m.mileage);
      stream.next(m.lighting_b);
      stream.next(m.horn_b);
      stream.next(m.leftLamp_b);
      stream.next(m.rightLamp_b);
      stream.next(m.bothLamp_b);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct can_out_MT4000_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::my_project_test::can_out_MT4000_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::my_project_test::can_out_MT4000_<ContainerAllocator>& v)
  {
    s << indent << "driverMode_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.driverMode_b);
    s << indent << "gearP_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gearP_b);
    s << indent << "loadBrake_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loadBrake_b);
    s << indent << "turtle_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.turtle_b);
    s << indent << "takeOver_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.takeOver_b);
    s << indent << "gear: ";
    Printer<int8_t>::stream(s, indent + "  ", v.gear);
    s << indent << "wheelAngle: ";
    Printer<int16_t>::stream(s, indent + "  ", v.wheelAngle);
    s << indent << "velocity: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.velocity);
    s << indent << "rpm: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.rpm);
    s << indent << "throttle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.throttle);
    s << indent << "electronic_break: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.electronic_break);
    s << indent << "vechleId: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.vechleId);
    s << indent << "engineSpeed: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.engineSpeed);
    s << indent << "batteryVoltage: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.batteryVoltage);
    s << indent << "faultTotal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.faultTotal);
    s << indent << "dump_bed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.dump_bed);
    s << indent << "loading: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.loading);
    s << indent << "faultCode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.faultCode);
    s << indent << "elecControlTemp: ";
    Printer<int8_t>::stream(s, indent + "  ", v.elecControlTemp);
    s << indent << "oil: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.oil);
    s << indent << "mileage: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.mileage);
    s << indent << "lighting_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.lighting_b);
    s << indent << "horn_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.horn_b);
    s << indent << "leftLamp_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.leftLamp_b);
    s << indent << "rightLamp_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.rightLamp_b);
    s << indent << "bothLamp_b: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.bothLamp_b);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MY_PROJECT_TEST_MESSAGE_CAN_OUT_MT4000_H
