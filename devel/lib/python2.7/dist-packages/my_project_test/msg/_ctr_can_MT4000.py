# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from my_project_test/ctr_can_MT4000.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class ctr_can_MT4000(genpy.Message):
  _md5sum = "d067cd566f42a2ca961103e47afa30a8"
  _type = "my_project_test/ctr_can_MT4000"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """## topic name : "ros_to_can_MT4000"
###############
bool driveMode_b    #自动模式开关 0:人工驾驶   1：自动驾驶
float32 throttle    #油门踏板指令 0-100
float32 electronic_break    #电制动踏板指令 0-100
float32 hydraulic_break #液压制动踏板指令 0-100
float32 steerAngle  #前轮转向角度[-350,250]，1=0.1度，左转为正数最大25度，右转为负数最值为-35度
bool park_b                 # 驻车制动, 0 无动作， 1 动作
bool loadBrake_b            # 装载制动, 0 无动作， 1 动作
int16 gear  #档位指令 0：空挡 1：前进档 2：倒车档
###############
float32 dump_bed 	  #货箱举升高度指令 0-100
bool powerSupply_b  # 断电指令, 0 无动作， 1 动作
bool engine_b   # 发送机熄火指令, 0 无动作， 1 动作
bool turtle_b   # 龟速模式, 0 无动作， 1 动作
bool lubricate_b    # 强制润滑, 0 无动作， 1 动作
bool firePrevent_b  # 消防, 0 无动作， 1 动作
bool emergencyBrake_b       # 紧急制动, 0 无动作， 1 动作
bool lighting_b # 照明, 0 无动作， 1 动作
bool horn_b # 喇叭, 0 无动作， 1 动作
bool leftLamp_b
bool rightLamp_b    # 转向灯, 0 无动作， 1 动作
bool bothLamp_b # 双闪, 0 无动作， 1 动作"""
  __slots__ = ['driveMode_b','throttle','electronic_break','hydraulic_break','steerAngle','park_b','loadBrake_b','gear','dump_bed','powerSupply_b','engine_b','turtle_b','lubricate_b','firePrevent_b','emergencyBrake_b','lighting_b','horn_b','leftLamp_b','rightLamp_b','bothLamp_b']
  _slot_types = ['bool','float32','float32','float32','float32','bool','bool','int16','float32','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       driveMode_b,throttle,electronic_break,hydraulic_break,steerAngle,park_b,loadBrake_b,gear,dump_bed,powerSupply_b,engine_b,turtle_b,lubricate_b,firePrevent_b,emergencyBrake_b,lighting_b,horn_b,leftLamp_b,rightLamp_b,bothLamp_b

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(ctr_can_MT4000, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.driveMode_b is None:
        self.driveMode_b = False
      if self.throttle is None:
        self.throttle = 0.
      if self.electronic_break is None:
        self.electronic_break = 0.
      if self.hydraulic_break is None:
        self.hydraulic_break = 0.
      if self.steerAngle is None:
        self.steerAngle = 0.
      if self.park_b is None:
        self.park_b = False
      if self.loadBrake_b is None:
        self.loadBrake_b = False
      if self.gear is None:
        self.gear = 0
      if self.dump_bed is None:
        self.dump_bed = 0.
      if self.powerSupply_b is None:
        self.powerSupply_b = False
      if self.engine_b is None:
        self.engine_b = False
      if self.turtle_b is None:
        self.turtle_b = False
      if self.lubricate_b is None:
        self.lubricate_b = False
      if self.firePrevent_b is None:
        self.firePrevent_b = False
      if self.emergencyBrake_b is None:
        self.emergencyBrake_b = False
      if self.lighting_b is None:
        self.lighting_b = False
      if self.horn_b is None:
        self.horn_b = False
      if self.leftLamp_b is None:
        self.leftLamp_b = False
      if self.rightLamp_b is None:
        self.rightLamp_b = False
      if self.bothLamp_b is None:
        self.bothLamp_b = False
    else:
      self.driveMode_b = False
      self.throttle = 0.
      self.electronic_break = 0.
      self.hydraulic_break = 0.
      self.steerAngle = 0.
      self.park_b = False
      self.loadBrake_b = False
      self.gear = 0
      self.dump_bed = 0.
      self.powerSupply_b = False
      self.engine_b = False
      self.turtle_b = False
      self.lubricate_b = False
      self.firePrevent_b = False
      self.emergencyBrake_b = False
      self.lighting_b = False
      self.horn_b = False
      self.leftLamp_b = False
      self.rightLamp_b = False
      self.bothLamp_b = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_B4f2Bhf11B().pack(_x.driveMode_b, _x.throttle, _x.electronic_break, _x.hydraulic_break, _x.steerAngle, _x.park_b, _x.loadBrake_b, _x.gear, _x.dump_bed, _x.powerSupply_b, _x.engine_b, _x.turtle_b, _x.lubricate_b, _x.firePrevent_b, _x.emergencyBrake_b, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 36
      (_x.driveMode_b, _x.throttle, _x.electronic_break, _x.hydraulic_break, _x.steerAngle, _x.park_b, _x.loadBrake_b, _x.gear, _x.dump_bed, _x.powerSupply_b, _x.engine_b, _x.turtle_b, _x.lubricate_b, _x.firePrevent_b, _x.emergencyBrake_b, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b,) = _get_struct_B4f2Bhf11B().unpack(str[start:end])
      self.driveMode_b = bool(self.driveMode_b)
      self.park_b = bool(self.park_b)
      self.loadBrake_b = bool(self.loadBrake_b)
      self.powerSupply_b = bool(self.powerSupply_b)
      self.engine_b = bool(self.engine_b)
      self.turtle_b = bool(self.turtle_b)
      self.lubricate_b = bool(self.lubricate_b)
      self.firePrevent_b = bool(self.firePrevent_b)
      self.emergencyBrake_b = bool(self.emergencyBrake_b)
      self.lighting_b = bool(self.lighting_b)
      self.horn_b = bool(self.horn_b)
      self.leftLamp_b = bool(self.leftLamp_b)
      self.rightLamp_b = bool(self.rightLamp_b)
      self.bothLamp_b = bool(self.bothLamp_b)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_B4f2Bhf11B().pack(_x.driveMode_b, _x.throttle, _x.electronic_break, _x.hydraulic_break, _x.steerAngle, _x.park_b, _x.loadBrake_b, _x.gear, _x.dump_bed, _x.powerSupply_b, _x.engine_b, _x.turtle_b, _x.lubricate_b, _x.firePrevent_b, _x.emergencyBrake_b, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 36
      (_x.driveMode_b, _x.throttle, _x.electronic_break, _x.hydraulic_break, _x.steerAngle, _x.park_b, _x.loadBrake_b, _x.gear, _x.dump_bed, _x.powerSupply_b, _x.engine_b, _x.turtle_b, _x.lubricate_b, _x.firePrevent_b, _x.emergencyBrake_b, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b,) = _get_struct_B4f2Bhf11B().unpack(str[start:end])
      self.driveMode_b = bool(self.driveMode_b)
      self.park_b = bool(self.park_b)
      self.loadBrake_b = bool(self.loadBrake_b)
      self.powerSupply_b = bool(self.powerSupply_b)
      self.engine_b = bool(self.engine_b)
      self.turtle_b = bool(self.turtle_b)
      self.lubricate_b = bool(self.lubricate_b)
      self.firePrevent_b = bool(self.firePrevent_b)
      self.emergencyBrake_b = bool(self.emergencyBrake_b)
      self.lighting_b = bool(self.lighting_b)
      self.horn_b = bool(self.horn_b)
      self.leftLamp_b = bool(self.leftLamp_b)
      self.rightLamp_b = bool(self.rightLamp_b)
      self.bothLamp_b = bool(self.bothLamp_b)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B4f2Bhf11B = None
def _get_struct_B4f2Bhf11B():
    global _struct_B4f2Bhf11B
    if _struct_B4f2Bhf11B is None:
        _struct_B4f2Bhf11B = struct.Struct("<B4f2Bhf11B")
    return _struct_B4f2Bhf11B
