# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from my_project_test/can_out_MT4000.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class can_out_MT4000(genpy.Message):
  _md5sum = "f717144ce310d9e9e5733e6820d8c923"
  _type = "my_project_test/can_out_MT4000"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """# ros topic name : can_to_ros_MT4000
# dada from MT4000 CAN

## can id 0X20B
bool driverMode_b           # 0: 有人驾驶，1： 无人驾驶
bool gearP_b                # 驻车制动挡反馈， 1=开关动作，0=开关无动作
bool loadBrake_b            # 装载制动挡反馈， 1=开关动作，0=开关无动作
bool turtle_b               # 龟速模式反馈， 1=开关动作，0=开关无动作
bool takeOver_b             # 0: 未接管，1：人工接管
int8 gear                   # 档位反馈 0：空挡 1：前进档 2：倒车档
int16 wheelAngle            # 前轮转向角度[-350,250]，1=0.1度，左转为正数最大25度，右转为负数最值为-35度
uint16 velocity             # 实时速度，1=0.1km/h
uint16 rpm                  # 驱动轮轮速, [0,3000]

## can id 0x21B
uint8 throttle              #油门踏板指令 1=1%, 0-100%
uint8 electronic_break      #电制动踏板指令 1=1%, 0-100%

## can id 0X22B
uint8 vechleId              # 车辆识别码，[0,255]
uint16 engineSpeed          # 发动机转速，[0,65535]
uint16 batteryVoltage       # 电池电压，0-300   系统供电电压  1=0.1V
uint8 faultTotal            # 整车故障, 0：无故障, 1：一般故障,2：严重故障,3：致命故障
uint8 dump_bed              # 货箱举升实时角度反馈    0-100   货箱举升实时角度反馈  1=1%
uint8 loading               # 载重量   0-255   载重量 1=1T

## can id 0X28B
uint8 faultCode             #故障代码   0-255     
                                    # 0x00：无
                                    # 0x01：系统故障（红）
                                    # 0x02：系统故障（黄）
                                    # 0x03：车辆低温故障
                                    # 0x04：电控箱低温报警
                                    # 0x05：电控箱高温报警
                                    # 0x06：前制动压力故障
                                    # 0x07：后制动压力故障
                                    # 0x08：自动润滑故障
                                    # 0x09：电制动高温故障
                                    # 0x0A：制动压力低故障
                                    # 0x0B：转向压力低故障
                                    # 0x0C：燃油量低故障
                                    # 0x0D：液压油温高故障
                                    # 0x0E：液压油位低故
                                    # 0x0F：预留
int8 elecControlTemp        # 电控箱温度信息反馈 0-125 电控箱温度信息反馈 -40 offset
uint8 oil                   # 燃油油位  0-100   燃油量 1=1%
uint32 mileage              # 车辆总里程数    0-2^32  车辆总里程数  1=1m/Bit
bool lighting_b             # 照明反馈, 0 无动作， 1 动作
bool horn_b                 # 喇叭反馈, 0 无动作， 1 动作
bool leftLamp_b
bool rightLamp_b            # 转向灯反馈, 0 无动作， 1 动作
bool bothLamp_b             # 双闪反馈, 0 无动作， 1 动作"""
  __slots__ = ['driverMode_b','gearP_b','loadBrake_b','turtle_b','takeOver_b','gear','wheelAngle','velocity','rpm','throttle','electronic_break','vechleId','engineSpeed','batteryVoltage','faultTotal','dump_bed','loading','faultCode','elecControlTemp','oil','mileage','lighting_b','horn_b','leftLamp_b','rightLamp_b','bothLamp_b']
  _slot_types = ['bool','bool','bool','bool','bool','int8','int16','uint16','uint16','uint8','uint8','uint8','uint16','uint16','uint8','uint8','uint8','uint8','int8','uint8','uint32','bool','bool','bool','bool','bool']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       driverMode_b,gearP_b,loadBrake_b,turtle_b,takeOver_b,gear,wheelAngle,velocity,rpm,throttle,electronic_break,vechleId,engineSpeed,batteryVoltage,faultTotal,dump_bed,loading,faultCode,elecControlTemp,oil,mileage,lighting_b,horn_b,leftLamp_b,rightLamp_b,bothLamp_b

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(can_out_MT4000, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.driverMode_b is None:
        self.driverMode_b = False
      if self.gearP_b is None:
        self.gearP_b = False
      if self.loadBrake_b is None:
        self.loadBrake_b = False
      if self.turtle_b is None:
        self.turtle_b = False
      if self.takeOver_b is None:
        self.takeOver_b = False
      if self.gear is None:
        self.gear = 0
      if self.wheelAngle is None:
        self.wheelAngle = 0
      if self.velocity is None:
        self.velocity = 0
      if self.rpm is None:
        self.rpm = 0
      if self.throttle is None:
        self.throttle = 0
      if self.electronic_break is None:
        self.electronic_break = 0
      if self.vechleId is None:
        self.vechleId = 0
      if self.engineSpeed is None:
        self.engineSpeed = 0
      if self.batteryVoltage is None:
        self.batteryVoltage = 0
      if self.faultTotal is None:
        self.faultTotal = 0
      if self.dump_bed is None:
        self.dump_bed = 0
      if self.loading is None:
        self.loading = 0
      if self.faultCode is None:
        self.faultCode = 0
      if self.elecControlTemp is None:
        self.elecControlTemp = 0
      if self.oil is None:
        self.oil = 0
      if self.mileage is None:
        self.mileage = 0
      if self.lighting_b is None:
        self.lighting_b = False
      if self.horn_b is None:
        self.horn_b = False
      if self.leftLamp_b is None:
        self.leftLamp_b = False
      if self.rightLamp_b is None:
        self.rightLamp_b = False
      if self.bothLamp_b is None:
        self.bothLamp_b = False
    else:
      self.driverMode_b = False
      self.gearP_b = False
      self.loadBrake_b = False
      self.turtle_b = False
      self.takeOver_b = False
      self.gear = 0
      self.wheelAngle = 0
      self.velocity = 0
      self.rpm = 0
      self.throttle = 0
      self.electronic_break = 0
      self.vechleId = 0
      self.engineSpeed = 0
      self.batteryVoltage = 0
      self.faultTotal = 0
      self.dump_bed = 0
      self.loading = 0
      self.faultCode = 0
      self.elecControlTemp = 0
      self.oil = 0
      self.mileage = 0
      self.lighting_b = False
      self.horn_b = False
      self.leftLamp_b = False
      self.rightLamp_b = False
      self.bothLamp_b = False

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_5Bbh2H3B2H4BbBI5B().pack(_x.driverMode_b, _x.gearP_b, _x.loadBrake_b, _x.turtle_b, _x.takeOver_b, _x.gear, _x.wheelAngle, _x.velocity, _x.rpm, _x.throttle, _x.electronic_break, _x.vechleId, _x.engineSpeed, _x.batteryVoltage, _x.faultTotal, _x.dump_bed, _x.loading, _x.faultCode, _x.elecControlTemp, _x.oil, _x.mileage, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 34
      (_x.driverMode_b, _x.gearP_b, _x.loadBrake_b, _x.turtle_b, _x.takeOver_b, _x.gear, _x.wheelAngle, _x.velocity, _x.rpm, _x.throttle, _x.electronic_break, _x.vechleId, _x.engineSpeed, _x.batteryVoltage, _x.faultTotal, _x.dump_bed, _x.loading, _x.faultCode, _x.elecControlTemp, _x.oil, _x.mileage, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b,) = _get_struct_5Bbh2H3B2H4BbBI5B().unpack(str[start:end])
      self.driverMode_b = bool(self.driverMode_b)
      self.gearP_b = bool(self.gearP_b)
      self.loadBrake_b = bool(self.loadBrake_b)
      self.turtle_b = bool(self.turtle_b)
      self.takeOver_b = bool(self.takeOver_b)
      self.lighting_b = bool(self.lighting_b)
      self.horn_b = bool(self.horn_b)
      self.leftLamp_b = bool(self.leftLamp_b)
      self.rightLamp_b = bool(self.rightLamp_b)
      self.bothLamp_b = bool(self.bothLamp_b)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_5Bbh2H3B2H4BbBI5B().pack(_x.driverMode_b, _x.gearP_b, _x.loadBrake_b, _x.turtle_b, _x.takeOver_b, _x.gear, _x.wheelAngle, _x.velocity, _x.rpm, _x.throttle, _x.electronic_break, _x.vechleId, _x.engineSpeed, _x.batteryVoltage, _x.faultTotal, _x.dump_bed, _x.loading, _x.faultCode, _x.elecControlTemp, _x.oil, _x.mileage, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 34
      (_x.driverMode_b, _x.gearP_b, _x.loadBrake_b, _x.turtle_b, _x.takeOver_b, _x.gear, _x.wheelAngle, _x.velocity, _x.rpm, _x.throttle, _x.electronic_break, _x.vechleId, _x.engineSpeed, _x.batteryVoltage, _x.faultTotal, _x.dump_bed, _x.loading, _x.faultCode, _x.elecControlTemp, _x.oil, _x.mileage, _x.lighting_b, _x.horn_b, _x.leftLamp_b, _x.rightLamp_b, _x.bothLamp_b,) = _get_struct_5Bbh2H3B2H4BbBI5B().unpack(str[start:end])
      self.driverMode_b = bool(self.driverMode_b)
      self.gearP_b = bool(self.gearP_b)
      self.loadBrake_b = bool(self.loadBrake_b)
      self.turtle_b = bool(self.turtle_b)
      self.takeOver_b = bool(self.takeOver_b)
      self.lighting_b = bool(self.lighting_b)
      self.horn_b = bool(self.horn_b)
      self.leftLamp_b = bool(self.leftLamp_b)
      self.rightLamp_b = bool(self.rightLamp_b)
      self.bothLamp_b = bool(self.bothLamp_b)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_5Bbh2H3B2H4BbBI5B = None
def _get_struct_5Bbh2H3B2H4BbBI5B():
    global _struct_5Bbh2H3B2H4BbBI5B
    if _struct_5Bbh2H3B2H4BbBI5B is None:
        _struct_5Bbh2H3B2H4BbBI5B = struct.Struct("<5Bbh2H3B2H4BbBI5B")
    return _struct_5Bbh2H3B2H4BbBI5B
